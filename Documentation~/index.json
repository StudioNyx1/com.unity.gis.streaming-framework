{
  "api/index.html": {
    "href": "api/index.html",
    "title": "| Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "This is the documentation for the Scripting APIs of this package."
  },
  "changelog/CHANGELOG.html": {
    "href": "changelog/CHANGELOG.html",
    "title": "Changelog | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "Changelog All notable changes to this package will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . [1.0.0-preview.2] - 2022-06-08 Modified Make MaterialType readonly due to immutable hashcode, use SerializableMaterialType in editor inspector Refactored UGObjectPool for better performances. Using Unity Mathematics when converting WGS84 Removed UGEditorWindow, UGGeodeticExtentInspector, UGSkyboxInspector Renamed FlyCamera.setClipPlanes to updateClipPlanes to prevent clash between the property and the method Renamed UGSimpleSceneObserver.Implementation to UGSimpleSceneObserver.IImplementation Changed UGSystemBehaviour / UGBehaviourPresenter delegates to events Set NodeContent, UGMath to internal Set MaximumSimultaneousContentRequests back to 10 Changed WGS84 to a static class Changed many properties / fields to readonly UGMetadata now store object values instead of serialized data. Changed editor classes by using a wrapper allowing easier testing and uniformized the UI layout. ### Added SerializableMaterialType to allow for easy MaterialType serialization Documentation to explain the calculation of terrain extents when the dataset starts with non-zero min level ### Fixed [1.0.0-preview.1] - 2022-05-11 Modified Use the SerializableDoubleBounds where necessary, since DoubleBounds is no longer serializable [1.0.0-preview.0] - 2022-05-11 Modified Separate extent modifier from UGSystem. Add sub-structs in UTR TileContent to group parameters. Add supported platform in the index doc page. Major refactor of the Universal Decoder. Now using Unity.Mathematics. Reimplementation of the priority queue to reduce idle CPU usage. Created FileType class allowing user own types. Allow to specify a different schema when decoding Ogc3dTiles. Created IOgcContentLoader allowing custom loaders. UnityTerrainContentLoader and OgcTilesetContentLoader now derive from HierarchyContentLoader defining our HLod decoding base solution. Create default material per alpha mode instead of overriding material properties at runtime. Change relative path to be streaming assets. ### Added Add a detail multiplier parameter on data sources to adjust level of detail per dataset. Ability to modify the maximum simultaneous loads via the the UGSystem. New UGSystem events: OnBeginProcessing, OnEndProcessing. OGC B3DM support. Add vertex color support for HDRP, URP, and Built-in render pipeline. Add transparency and alpha-test support for HDRP, URP, and Built-in render pipeline. ### Fixed Delay unloading to prevent unnecessary unloads when the observer come back to its previous position. Unity Earth zoom 0 is now loaded when the camera is far. Link from the inspector to the UGSystem advanced options was not valid. Sphere Bound requesting an array of 12 floats instead of 4 withing Ogc3DTiles. Ogc3DTiles nulls checks in case of empty content. Removed duplicate UGMetadataBehaviour component creation. Stability issues in UGSynchronizationContext tests. Inconsistent serialization of the UGExtentModifierBehaviour. Lists not getting populated in new System Inspector in Unity 2021. Update refinement mode and geometric error on tileset loading root node OGC 3D Tiles not applying Detail Multiplier to root tiles. [0.5.1-preview.0] - 2021-12-23 Fixed Support counterclockwise extent modifier Support negative DBound with extent modifier Connect URPLit smoothness to the underlying Unity material [0.5.0-preview.0] - 2021-11-04 Added Support for Omnidirectional camera Support material customization per instance data [0.4.0-preview.0] - 2021-11-03 Added Support relative path for data sources Fixed Ability to unload nodes that do not have content [0.3.3-preview.0] - 2021-10-03 Added Support for variable resolution Terrain Tiles Support edge extrusion for uncontinuous edges in mesh editor [0.3.2-preview.0] - 2021-09-16 Modified Migrate to Standard Unity Package format Split High Precision Framework repo from Streaming Framework Migrate documentation from Sphinx to Unity DocTools Updated to latest GLTFast Improved performance of many WGS84 functions ### Added Ability to stream UTR files for terrain Skirting in extent modifier Add control over mipmaps and aniso level Default material when material is not specified in GLTF file ### Fixed Compatibility with the Built-In Render pipeline Bugs related to geometric error, bounds and error specs in BVH [0.3.1-preview.3] - 2021-06-04 Added Support for multiple cameras A geodetic extent object which can be reused to define an extent for modifiers. The extent can also be modified at play-time. ### Modify Extent modifier to use the new geodetic extent object Extent modifier to support multiple vertex streams Documentation to reflect changes made to the extent modifier. ### Fix Memory leak which was detected in previous version [0.3.1-preview.2] - 2021-05-15 Added Support for hierarchical OGC 3DTiles tilesets Ability to generate HP Framework package only ### Modified Move 3DTile json parsing to another thread Split Universal decoder processing over multiple frames to reduce overall impact on performance Prioritize tiles based on the ratio between their geometric error and their error specification, causing closer objects to load first rather than the opposite in previous implementation. [0.3.1-preview.1] - 2021-05-12 Added Geospatial Synchronization Context to better control execution time of await/async in GLTFast. ### Modifier Make it possible to have an Camera that is located in world space rather than being located in Universe space. Make it possible for extent modifier to deal with children [0.3.1-preview.0] - 2021-05-10 Added Universal OGC 3D Tiles loader Dependency on GLTFast for 3D tile loader ### Modified HPTransform optimizations Changes to the internal presenter structure to support children (required for GLTFast) [0.3.0-preview.0] - 2021-04-02 Added HDRP Support via HDRP Material Factory UGSystem Modifier Stack UGExtentModifier to remove or contain dataset extents HDRP Test project (dev only) ECEF Coordinate system inspector Force-Lit texture support on Cesium-Native, allowing unlit datasets to be pushed into lit shaders for relighting Presenter concept has been added to UGSystem, allowing datasets to be spawned on different render layers as well as on different GameObjects. ### Modified Significant changes to documentation Moved away from .unitypackage and into package manager workflow UGSystem has become UGSystemBehaviour. Similar name changes have been made across the API for a uniform naming convention and preparation for future DOTS support. Changed the way sample datasets are loaded via package manager Import through package manager rather than .unitypackage UGSystem now uses a node graph for it's processing across multiple internal modules. This standardizes the way processing is done within the system. HPTransform coordinate system is now saved to editor preference rather than static variables, ensuring coherence from edit to play mode and from HPTransform to HPRoot and vice-versa. Geodetic coordinate system inspector now shows pitch, yaw and roll rather than heading, pitch, roll. Order has been changed to fit with Euler angles and nomenclature has been standardized to something more familiar. Build script has been cleaned up (dev only) Demo application has been migrated to HDRP UGSystem configuration errors will show a single explicit error message rather than pop an undescript message on every frame. Cesium Native error messages are still non-descript. Implemented proper error message on missing Cesium-Ion token [0.2.1-preview.0] - 2021-02-25 Fixed Perpetual dialog that opened up when adding an HPTransform to a prefab. [0.2.0-preview.0] - 2021-02-22 Modified THIS IS A COMPLETELY NEW VERSION OF THE API THAT INCORPORATES A HIGH PRECISION RENDERING FRAMEWORK. SEE BELOW FOR PRIMARY CHANGES: The UGCamera must now be a child of the UGSystem The UGCamera must now have an HPTransform component The UGSystem must now have an HPRoot component The UGSkybox must now be a child of the UGSystem The UGSkybox must now have an HPTransform component Static rebasing is no longer implemented by the UGSystem, rather it is implemented via the HPRoot. This allows for dynamic rebasing as well as static rebasing, via the HPRoot/HPTransform. All objects instantiated by the UGSystem now have an HPTransform component. [0.1.0-preview.5] - 2020-12-15 Added Docs: Doxygen + Breathe for API docs Docs: Wrote API docs for primary classes Makefile: Automated zip archive for builds Makefile: Added Unity Tests to build pipeline ### Modified Fly Camera script has been modified such that it is no possible to disable the automatic clip plane adjustments Build Preprocessor populates required shaders in build Terrain shaders had a Red Color that was shown when textures are not loaded. This was intended for debugging issues during development, not in a release. A UNITY_GEOSPATIAL_DEBUG define has been added to enable or disable this feature. Since new projects do not have this define, a black color will be shown instead, by default. ### Fixed Fixed bug where a light in b3dm file would cause the application to crash. Fly Camera script has been fixed such that it is no longer possible for the camera to get stuck looking down. [0.1.0-preview.4] - 2020-11-07 Added Docs: Added license file to .unitypackage Docs: Added license file in root of build product Docs: Added page to guide use of multiple layers ### Modified Fly Camera now controls near clip plane and far clip plane automatically Refactored some private variables in Fly Camera to match coding standard [0.1.0-preview.2] - 2020-11-03 Added Docs: Screenshots for more explicit documentation Docs: How to disable fog in Getting Started ### Changed Changed project file structure Updated Makefile accordingly Built documentation into the Makefile [0.1.0-preview.1] - 2020-11-02 Added Initial release for internal review"
  },
  "index.html": {
    "href": "index.html",
    "title": "Home Page. | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "Home Page. This is the home page for this package."
  },
  "license/index.html": {
    "href": "license/index.html",
    "title": "| Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "window.location.replace('LICENSE.html')"
  },
  "license/LICENSE.html": {
    "href": "license/LICENSE.html",
    "title": "| Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "Geospatial Streaming Framework © 2022 Unity Technologies Licensed under the Unity Companion License for Unity-dependent projects (see https://unity3d.com/legal/licenses/unity_companion_license ). Unless expressly provided otherwise, the Software under this license is made available strictly on an “AS IS” BASIS WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED. Please review the license for details on these and other terms and conditions."
  },
  "manual/Architecture/universal-decoder.html": {
    "href": "manual/Architecture/universal-decoder.html",
    "title": "Universal Decoder | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "Universal Decoder The universal decoder is a decoder implementation that has the intent of supporting many different content types within the same decoder, provided the given content is HLODed and can be represented within a bounding volume hierarchy. In its current state, the Universal decoder can be used to decode a subset of the 3DTiles specification, GLTF files as well as Unity GIS terrain data. Internal Structure Looking at the internal structure of the Universal Decoder class, we can see that it is composed of many simple classes that each play their own role in spatializing and loading pieces of content. Let us go over them in order to better understand their roles and responsibilities. DetailObserverData : The DetailObserverData class is the starting point for any decoder. It represents cameras and sensors in the scene such that we can determine how much detail is required at any point in space. TargetStateController : The TargetStateController uses the DetailObserverData in order to determine which parts of the BoundingVolumeHierarchy needs to be expanded and further detailed and which parts should be collapsed, removing detail and, thus, reducing the overall memory footprint. The HierarchyTargetControl , sets the target state of each node in the hierarchy such that the target state represents the steady state of the hierarchy. BoundingVolumeHierarchy : The BoundingVolumeHierarchy simply represents the state of system. All of the information relating to each node is contained within the hierarchy. However, the hierarchy is a passive class that does not do any processing. CurrentStateController : The CurrentStateController translates commands to load, unload, show and hide nodes such that both the current state in the BVH is up-to-date and so that the corresponding instructions have been sent to the UGContentManager . ExpansionScheduler : The ExpansionScheduler observes the target state of each node and determines the order in which they should be expanded and/or collapsed in order to maximize the level of detail seen by the user as well as keep the system as reactive as possible when cameras change positions. It has a readonly relationship with the hierarchy (with the exception of a cache it can use to store implementation-specific data) and interacts with the CurrentStateController to change the state of the hierarchy. UGContentManager : The UGContentManager makes use of multiple registered UGContentLoader in order to load nodes of various content types. It is also responsible for building a simultaneous download queue such that multiple UGContentLoader , which can be blocked temporarily by external resources, can work in parallel. UGCommandBuffer : The UGCommandBuffer allows content loaders to work on threads that are separate from the main thread and resynchronizes a series of output commands with the main thread. This way, mesh, texture and material data can be deserialized off of the main thread, but be instantiate using UnityEngine types on the main thread. Note: For the sake of simplicity, the diagram below does not illustrate the interfaces that link the classes to one another. For this purpose, detailed diagrams have been added in the subsequent sections of this document. Bounding Volume Hierarchy The BoundingVolumeHierarchy is responsible for storing data pertaining to each node in the BVH as well as their target state and current state. Its only purpose is to represent the state and relation of the nodes in memory. This class is broken into four separate interfaces to limit how external classes can affect the BVH: IEditHierarchyNodes : Allows external classes to add and remove nodes from the BVH. This is primarily be used by the UniversalDecoder class for initialization as well as various UGContentLoader in order to dynamically expand the size of the BVH. IEditTargetState : Allows the TargetStateController to read the information required to determine and set the target state of each node. IEditCurrentState : Allows the CurrentStateController to set the current state of the node as well as query a node's NodeContent such that it can also trigger the loading process. IPrioritizeHierarchy : Allows the CompansionScheduler to read the target state of each node of the hierarchy, information pertaining to the node's error as well a cache that the CompansionScheduler can use to store data required for its internal logic. Other than the aforementioned cache, this interface is essentially readonly. Target State Controller Class The TargetStateController communicates with the IEditHierarchyTargetState interface, which allows it to explore the hierarchy, obtain information pertaining to each node's geometric error and bounding volume in order to compute a target state as well as an error specification. The responsibility of computing the error specification has not be separated from that of computing the target state because, for the sake of computational efficiency, we do not want to be computing the error specification for all nodes, we simply want to compute the error specification of any node which has a parent with an expanded target state. The error specification of other nodes is irrelevant and does not need to be computed, thus saving a tremendous amount of CPU time. The TargetStateController also needs to receive none or more DetailObserverData. Should no DetailObserverData be provided, all target states should be set to unloaded. The DetailObserverData is used to determine whether a node should be expanded or collapsed, where a result of expanded from one detail observer supersedes a result of collapsed from another. Unlike the current state, the target state does not dictate whether a node should be loaded or not. It only determines whether a node is expanded or collapsed. Current State Controller Class The CurrentStateController has the purpose of ensuring that the current state of the hierarchy is always valid and that the corresponding content has been loaded and has the appropriate visibility status. It exposes a simple set of methods which allows the CompansionScheduler to expand and collapse nodes without needing to worry about whether a node is loaded or not and without needing to worry about which instructions should be sent to the UGContentManager . Additionally, it provides information to the CompansionScheduler as to how many nodes are currently being loaded such that it can throttle the number of nodes to expand and limit the number of simultaneous web and IO operations. ExpansionScheduler The ExpansionScheduler observes the difference between each node's target state and it's current state and progressively causes the two to converge. Using the error metrics, it also determines the order in which nodes should be collapsed and expanded. It holds an essentially readonly interface to obtain the information it needs from the BVH and it applies the desired changes via the ICurrentStateController . The ExpansionScheduler also has a data cache that it can use on each node where it can store timers or other node-specific variables needed for internal logic. Bounding Volume Hierarchy State The BoundingVolumeHierarchy relies heavily on the concept of target and current state. All nodes have both a target state and a current state. Understanding how these states relate to each is key to understanding how the bounding volume hierarchy functions. Target State The target state represents the steady-state of each node without consideration for optimizations. In short, it expresses the visibility of the nodes should the DetailObserverData remain unchanging for an infinite amount of time. It is a binary state that can either be set to Expanded or Collapsed . When collapsed, this indicates that it's children should not be visible and that the content of the given node should be. When expanded, this indicates that it's children should be visible but the given node should respect the replacement mode parameter. However, a change of state may take multiple frames to come into effect, which brings us to the current state. Current State The current state represents the actual state of a node and its relevant content. Unlike the target state, the current state is not a single binary but rather a triplet of binary states. Each of these binary states are detailed below: Name False True Expanded Collapsed, children are hidden Expanded, children may be visible Loaded Node content has not yet been loaded Node content has been loaded Visible Node content is hidden Node content is visible Given the above states, it is obvious that some states are not possible and cannot make sense. Here are a few cases that need to be safe-guarded against: A node cannot be visible and unloaded, regardless of the expanded state. If a node is expanded and its refinement mode is additive, it cannot be hidden."
  },
  "manual/FileFormats/ogc-3d-tiles.html": {
    "href": "manual/FileFormats/ogc-3d-tiles.html",
    "title": "OGC 3D Tiles | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "OGC 3D Tiles The Geospatial Framework offers a partial support for the OGC 3DTiles standard. The following is a list of features that not or are only partially supported: Section 11 - Declarative styling specification is not supported at all In terms of content, only GLB payloads are currently supported. b3dm, i3dm pnts and cmpt contents are not supported. However, nested tilesets are properly supported. Link to 3D Tiles specification: https://docs.opengeospatial.org/cs/18-053r2/18-053r2.html"
  },
  "manual/FileFormats/unity-terrain-mesh.html": {
    "href": "manual/FileFormats/unity-terrain-mesh.html",
    "title": "Unity Terrain Mesh - Version 1.0 | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "Unity Terrain Mesh - Version 1.0 The Unity terrain mesh format is a proprietary mesh format designed to be streamed efficiently within the geospatial streaming framework. Its primary objective is to provide data that can easily be converted into a UnityEngine.Mesh but formatted in such a way that it can easily be procedurally augmented to attenuate or remove seams between tiles and efficiently sampled such that the application layer can easily determine heigh above ground at any point in space. File structure The Unity Terrain Mesh is designed to be hosted on a static web server or within a local folder structure. The imagery and elevation, generated at multiple resolutions is distributed within a quad tree structure such any area of interest can be efficiently fetched at any resolution. The structure of the tree is defined within a terrain.json file, which informs the streamer of the extent of the dataset, its maximum resolution, as well as other parameters which may affect the folder structure's layout. The folder structure is expected to be as follows: <Root Folder> - terrain.json - 0 // zoom level - 0 // column number - 0.utr // row terrain - 0.jpg // row imagery - 1.utr - 1.jpg - 2.utr - 2.jpg - ... - 1 - ... - 2 - ... - ... - 1 - ... Row and Column order Rows and columns will be ordered north to south and west to east respectively. In other words, the north-most row for a given zoom level will have a row number of zero and the west-most column will have a column number of zero. Terrain.json Specification The terrain.json files allows the streamer to predict the exact folder structure such that it can directly query the files of interest. It contains the following properties within a json object: Example terrain.json File The following is an example terrain.json file which describes a double-head quad-tree which spans the entire globe, down to zoom-level 13. { \"version\":\"1.0\" \"extent\": { \"minLat\": -90, \"maxLat\": 90, \"minLon\": -180, \"maxLon\": 180 }, \"setLimits\": { \"layout\": 277, \"minLevel\":0, \"maxLevel\":13, \"minCol\":0, \"minRow\":0, \"maxCol\":1, \"maxRow\":0 } \"content\": { \"terrainFormat\":\"utr\", \"terrainUri\":\".\", \"imageryFormat\":\"jpg\", \"imageryUri\":\".\" } } Terrain Property Type Description Default version string The major and minor version of the file format. Minor version increments must remain backward compatible. reqd extent object The dataset's extent reqd setLimits object Properties pertaining to the file structure reqd content object Properties pertaining to the content files reqd Terrain.version The version of the terrain format being used which follows semantic versioning. Terrain.extent Property Type Description Default minLat double The minimum latitude of the dataset. This number is expected to be between -90 and 90. reqd maxLat double The minimum latitude of the dataset. This number is expected to be between -90 and 90. reqd minLon double The minimum longitude of the dataset. This number is expected to be between -180 and 180. If a local dataset were to sit on the anti-meridian, splitting it into two datasets would be required. Few datasets are expected to require this. reqd maxLon double The maximum longitude of the dataset. This number is expected to be between -180 and 180. If a local dataset were to sit on the anti-meridian, splitting it into two datasets would be required. Few datasets are expected to require this. reqd Terrain.setLimits Property Type Description Default globalDiv int An integer that defines how the tile structure maps to real-world coordinates. See section on Terrain.setLimits.Layout for more information. reqd minLevel int The minimum zoom level of the dataset. For a full dataset, this should always be zero. However, datasets can start at any zoom level. 0 maxLevel int The maximum zoom level of the dataset, inclusively. In other words, if a value of 10 were to be contained in this property, it would be expected that the folder structure contains zoom-levels from [0, 10] . reqd minCol int The minimum column (inclusively) of the dataset within the minimum zoom level. reqd maxCol int The maximum column (inclusively) of the dataset within the minimum zoom level. reqd minRow int The minimum row (inclusively) of the dataset within the minimum zoom level. reqd maxRow int The maximum row (inclusively) of the dataset within the minimum zoom level. reqd Calculation of terrain extents for datasets with non-zero minimum level The value of minLat , maxLat , minLon , and maxLon are relative to the min level of the dataset. The following is an example which shows the property values of Terrain.extent and Terrain.setLimits , when the dataset with layout 277 starts with a min level > 0: \"extent\": { \"minLat\": 0, \"maxLat\": 90, \"minLon\": -90, \"maxLon\": 90 }, \"setLimits\": { \"layout\": 277, \"minLevel\":1, \"maxLevel\":2, \"minCol\":1, \"minRow\":1, \"maxCol\":2, \"maxRow\":1 } Terrain.content Property Type Description Default terrainFormat string See Terrain.content.terrainFormat for more information \"none\" terrainUri string Uri to the folder containing the terrain data \".\" imageryFormat string See Terrain.content.imageryFormat for more information \"none\" imageryUri string Uri to the folder containing the imagery data \".\" Terrain.setLimits.Layout This 2D distribution of tiles can be laid out multiple ways to represent the globe. The global division defines how the 2D distribution maps to a 3D surface such as the earth. Currently, only one division mode is specified but many more could be specified to represent bodies other than the earth as well as accommodate S2-like layouts, for example. ID Z0 Dims (WxH) Subdivision Proportions Elevation Reference 277 2x1 Equal and uniform geodetic subdivision according to EPSG4326. For example, a tile measuring 45deg x 45deg would break into four tiles measuring 22.5deg x 22.5deg, regardless of latitude. WGS84 Terrain.content.terrainFormat The format of the terrain files contained within the dataset. This can take one of the following values: none: Indicates that no elevation data is contained within the dataset. utr: Indicates that the elevation data is in utr format, as described in the present document. See the section on Terrain Format for more information about the utr files. Terrain.content.imageryFormat The format of the imagery files contained within the dataset. This can take the following values: none: Indicates that no imagery is provided in the dataset. jpg: Indicates that jpg files have been provided in the dataset png: Indicates that png files have been provided in the dataset. See the section on Imagery Format for more information about the expected imagery formats. Terrain Format A .utr file is a binary file that contains mesh information about the terrain. Each file is inherently self-sufficient and can be individually turned into a mesh. The layout of the binary file follows the following C# data struct: [StructLayout(LayoutKind.Sequential)] public struct Header { public fixed byte[4] magic public unsigned int fileByteSize; public int type; public unsigned short majorVersion; public unsigned short minorVersion; } public struct TileData { public unsigned int layout; public double minLon; public double maxLon; public double minLat; public double maxLat; public double minElevation; public double maxElevation; public float geometricError; public unsigned short vertexBufferOffset; public unsigned short vertexBufferCount; public unsigned short trianglesOffset; public unsigned short trianglesCount; public unsigned short northEdgeStart; public unsigned short northEdgeCount; public unsigned short northEdgeExtra; public unsigned short eastEdgeStart; public unsigned short eastEdgeCount; public unsigned short eastEdgeExtra; public unsigned short southEdgeStart; public unsigned short southEdgeCount; public unsigned short southEdgeExtra; public unsigned short westEdgeStart; public unsigned short westEdgeCount; public unsigned short westEdgeExtra; } [StructLayout(LayoutKind.Sequential)] public struct Vertex { public unsigned short u; public unsigned short v; public unsigned short z; public short nu; public short nv; } [StructLayout(LayoutKind.Sequential)] public struct Triangle { public short a; public short b; public short c; } The header must correspond to the first bytes contained within the file. If the tile is a non-empty tile, the TileData must then immediately follow. However, the byte structure following these two sections can be arranged and padded arbitrarily, provided that the start address of the buffers have been correctly attributed within the header. Header The header is comprised of the following properties: Property Description magic 4 unique bytes to identify the file. These are always utrm fileByteSize The total size of the file, in bytes. type The type of the given terrain data 0 = Empty without children 1 = Empty with children 25 = TileData without children 26 = TileData with children majorVersion The major version of this tile. An increment in the major version is expected to require a new version of the decoder minorVersion The minor version of this tile. An increment in the minor version is expected to continue working with previous decoders and only provides extra information. TileData If the terrain is of tile type, it is expected that a tiledata block follows immediately after then header. The tileData block has the following properties: Property Description layout Same as Terrain.setLimits.layout minLon The minimum longitude of the tile, in degrees maxLon The maximum longitude of the tile, in degrees minLat The minimum latitude of the tile, in degrees maxLat The maximum latitude of the tile, in degrees minElevation The minimum elevation of the tile, relative to the reference specified in the terrain.json file. maxElevation The maximum elevation of the tile, relative to the ellipsoid specified in the terrain.json file. vertexBufferStart The start of the vertex buffer relative to the start of the file, in bytes. vertexBufferCount The number of vertices represented within the vertex buffer. trianglesStart The start of the index buffer relative to the start of the file, in bytes. trianglesCount The number of triangles represented in the index buffer. northEdgeStart The starting index of the vertices which compose the north edge of the tile. northEdgeCount The number of vertices which compose the north edge of the tile. northEdgeExtra The last vertex of the north edge. Can be set to 65535 if unused. eastEdgeStart The starting index of the vertices which compose the east edge of the tile. eastEdgeCount The number of vertices which compose the east edge of the tile. eastEdgeExtra The last vertex of the east edge. Can be set to 65535 if unused. southEdgeStart The starting index of the vertices which compose the south edge of the tile. southEdgeCount The number of vertices which compose the south edge of the tile. southEdgeExtra The last vertex of the south edge. Can be set to 65535 if unused. westEdgeStart The starting index of the vertices which compose the west edge of the tile. westEdgeCount The number of vertices which compose the west edge of the tile. westEdgeExtra The last vertex of the west edge. Can be set to 65535 if unused. Note 1: Edge data is expected to be laid out such that they are ordered clock-wise when viewed from above. Note 2: Edge data is expected to include both corners. Note 3: The extra vertex can be used to indicate the last vertex of the edge, should the last vertex need to be discontinuously laid out in the vertex buffer. If possible, prefer a continuous vertex layout and set the extra to 65535. It is normal and expected that at least one edge requires the use of the extra. Vertex Data The vertex data is comprised of the following properties: Property Description u The longitude of the vertex relative to minLon and maxLon . A value of 0 will make the longitude of this vertex correspond exactly to minLon and a value of 2^16-1 would correspond exactly to maxLon . Vertices on the western-most edge of the tile are expected to have values of 0 and vertices on the eastern-most edge of the tile are expected to have values of 2^16-1 . v The latitude of the vertex relative to minLat and maxLat . A value of 0 will make the latitude of this vertex correspond exactly to minLat and a value of 2^16-1 would correspond exactly to maxLat . Vertices on the northern-most edge of the tile are expected to have values of 0 and vertices on the southern-most edge of the tile are expected to have values of 2^16-1 . z The elevation of the vertex relative to maxElevation and minElevation . A value of 0 will make the elevation of this vertex correspond exactly to minElevation and a value of 2^16-1 would correspond exactly to maxElevation . It is normal and expected normal for values of 0 and 2^16-1 to appear in this field. n u & n v Two of the tree normal values of any given vertex. See section on Calculating Normals for more information. Index Data The index data is used to form triangles with the vertices specified in the vertex buffer. Each triangle is comprised of 3 vertices arranged in clock-wise winding order. The integers used represent the index of the vertex within the buffer. In other words, a value of 0 would represent the very first vertex within the vertex buffer. Calculating Normals Normals provided within a tile need to be converted over to normals that can be represented on the GPU. This is how to achieve this conversion: Assuming x, y and z which follow the ECEF standard and a set of reference vectors r u , r v and r w which form a orthonormal set where r w represents an up vector relative to the elevation reference, r u represents a vector pointing due-east and r v represents a vector pointing due-north. The normal vector n would be derived using the following expressions: m u = 1/32768 * n u m v = 1/32768 * n v m w = sqrt(1 - m u 2 - m v 2 ) n = m u * r u + m v * r v + m w * r w Conversely, for each vertex in a mesh defined in ECEF, the same r u and r v described above can be used to compute n u and n v from normalized vector n defined within the ECEF coordinate system. n u = 32768 * dot(n, r u ) n v = 32768 * dot(n, r v ) Imagery Format The imagery of each cell is expected to respect the following constraints: Imagery is expected to be either in jpg or png format. The format and resolution of all images at all zoom levels is identical. The resolutions of the images are equal in both dimensions. The resolution of the imagery is a power of 2. The color space of the imagery is encoded sRGB. The images are oriented such that north is up and east is right."
  },
  "manual/GettingStarted/adding-multiple-datasets.html": {
    "href": "manual/GettingStarted/adding-multiple-datasets.html",
    "title": "Adding Multiple Layers | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "Adding Multiple Layers This section assumes that you have already familiarized yourself with the First Time Setup section and understand how to import the package, create a scene and integrate the UnityGeospatial's core components. Creating a New Geospatial Layer If you followed the getting started guide, you now have a low-resolution dataset that covers the entire planet. For this tutorial, we will add a high resolution inset. Download the HillAirforceBase-15cm-v1.0 from the geospatial release folder and decompress the archive anywhere on your machine. In your asset's right-click context menu select Create -> Geospatial -> Data Sources -> OGC 3DTiles . Name this newly created asset HillAirforceBase . Select the asset and, in the inspector, set the URI field of the asset to file:///c:/path-to-dataset/tileset.json Since this data source is unlit by default, which won't take advantage of the HDRP, let's also force the data source's materials to be lit by changing the Lighting setting from Default to Lit . Adding Multiple Layers to the UG System We will instruct our UG System to use multiple layers. In the UG System's inspector configure the UG System such that it has two layers: UnityEarth and HillAirforceBase Creating a Geodetic Extent At this point, if we hit play, we will see both datasets. However, there are areas where the terrain comes out in front of the inset, which doesn't look great. In order to avoid this, we will add a modifier which will cut out the terrain from under our inset. However, before we do so, we need to define the extent that will be used to cut out our terrain. In the project window's context menu, select Create -> Geospatial -> Data Type -> Geodetic Extent Give this asset a meaningful name such as HAFB-Extent Hit play and navigate to the region of interest. Select our newly created asset and add a new point in the inspector. Enter Hill Airforce Base's lat/long: 41.109, -111.980 A single point should also appear in the scene view at the entered coordinate. Form a convex shape by adding points and positioning them in the scene view. Once you are done editing the extent, make sure to click the Validate & Apply button in the inspector. Applying the extent as a modifier Create an empty GameObject as a child of the UGSystem and call it ExtentModifier Add an ExtentModifierBehaviour component to the newly created object. Add this modifier to the UGSystem's modifier stack. Set the extent to the one we created in the previous step. Add the terrain layer to the Difference mask. Add the high resolution inset to the Intersection mask. Hit play to observe the effect of this modifier."
  },
  "manual/GettingStarted/first-time-setup.html": {
    "href": "manual/GettingStarted/first-time-setup.html",
    "title": "First Time Setup | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "First Time Setup Open or Create a Compatible Project The Unity Geospatial Framework currently supports the built-in render pipeline, the Universal Render Pipeline as well as the High Definitions Render Pipeline for Unity versions 2020.2. and above. Although you can use any of the aforementioned render pipelines and any project you would like, this tutorial will guide you through the process of getting up and running with HDRP inside of a fresh Unity project. To begin, create a new project using the HDRP template. Import the Package In order to import the package, we will use Unity's Package Manager. Open it by clicking Window -> Package Manager Once the package manager has appeared, click on the + icon at the top left of the screen and select Add package from disk... . Add all three provided packages, in the following order. The geospatial.streaming package must be added last as it has dependencies on the two other packages. com.atteneder.gltfast com.unity.highprecision com.unity.geospatial.streaming Basic Scene Setup Create a new scene by clicking File -> New Scene and select the Basic Outdoor (HDRP) scene template. Delete the Main Camera . In the Scene Hierarchy's context menu, select Geospatial -> Geospatial System . This will create a new GameObject in the scene with a UG System component and a few child objects. Creating a Data Layer By default, the UGSystem doesn't display anything. We need to create and provide a geospatial data source. We're going to begin by creating a data source that will point the UGSystem towards the Unity Earth dataset. Download the UnityEarth-80m-v1.0 from the geospatial release folder and decompress the archive anywhere on your machine. The 610m dataset can also be used. The lower resolution makes the download much smaller. In your asset's right-click context menu select Create -> Geospatial -> Data Sources -> OGC 3DTiles . Name this newly created asset UnityEarth . Select the asset and, in the inspector, set the URI field of the asset to file:///c:/path-to-earth-asset/tileset.json Since this data source is unlit by default, which won't take advantage of the HDRP, let's also force the data source's materials to be lit by changing the Lighting setting from Default to Lit . Configure the UGSystem Select the UGSystem and, in the inspector, apply the following configurations: Leave the Scene Observers untouched. By default, it will point towards the camera object contained within the system. Add the UnityEarth asset you created in the previous step to the data sources. Leave the modifiers untouched. Leave the Presenters untouched. By default, there will be a single presenter which will instantiate all of your data sources on the default render layer. Set the material factory field to the HDRP Material Factory . Leave the advanced options untouched. Adjust Settings IMPORTANT! The default settings in a new HDRP project are not ideal to get started with the geospatial framework. We recommend making the following simple changes just to get started. Keep in mind these settings are just a functional starting point. Different applications may/will required significantly different settings from the ones shown below. Input System Under Edit -> Project Settings -> Player -> Other Settings -> Active Input Handling make sure the value is either set to Input Manager (Old) or to Both . This is only necessary for the example Fly Camera script to work. If you write your own camera controller, feel free to use the input system of your choosing. Fog By default, the fog will completely occlude the planet on both URP and HDRP. To disable it, select the Sky and Fog Volume in the Hierarchy window and, in the inspector, enable the fog override and disable the fog. Procedural Sky Settings HDRP has default sky settings that are not optimal for low resolution terrain. We recommend using these settings to get started. Note that the values we are proposing are not realistic values. However, without these settings, you will experience a horrendous golf-ball effect when the camera is away from the surface of the planet. We are working on finding a better solution for the future. Testing and Exploring When you enter play mode, it will take a few seconds for the first geometry to load. Normally, if everything is working as expected, you should be seeing something similar to the following screenshot. Now, feel free to explore the world, using the Fly Cam! It is very similar to Unity's scene camera controls: w a s d : Move and Strafe e : Move Up q : Move Down Right Mouse Button : Pan / Tilt Shift : Fast Move Scroll : Increase/Decrease movement speed"
  },
  "manual/GettingStarted/frequently-asked.html": {
    "href": "manual/GettingStarted/frequently-asked.html",
    "title": "Frequently Asked Questions | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "Frequently Asked Questions How do I upgrade the project? In order to upgrade the package to a newer version, simply remove the old package and point towards the new package. Why is everything coming out white? It is very likely that the default fog settings are too aggressive. We recommend disabling the fog completely during setup then adjusting it for your application. Why is everything coming out black? It is very likely that the default fog settings are too aggressive. We recommend disabling the fog completely during setup then adjusting it for your application. Why is nothing being rendered? Firstly, start by checking whether geometry is being generated in the scene. If no geometry is being generated, double check you UGSystem configuration. If geometry is being generated, check the camera's clipping planes. Planet-scale scenes will require very large clipping plane values while moving close to the surface of the globe will required much smaller clipping plane values. How do I host my own 3DTiles Package? 3DTiles can easily be hosted on a static web server. This can be done with nodejs, python or Apache. Once the web server is up and running, simply create a 3DTile dataset that points towards it. How can I add a custom asset to the scene? GameObjects can be added to the scene as you normally would in Unity. However, unless you are using a static rebasing scheme, you will be required to add an HPTransform to the root GameObject. See Known Limitations for a better understanding of what assets may not work as expected."
  },
  "manual/GettingStarted/known-limitations.html": {
    "href": "manual/GettingStarted/known-limitations.html",
    "title": "Platform Support | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": ".md# Known Limitations Platform Support Currently, only 64 bit windows is fully tested. However, the framework is reported to work on other platforms. Physics Physics can only work in a static rebasing context due to the performance cost of moving colliders. Navigation Mesh Unity's navigation system cannot pull data from the Geospatial framework at the current time. Additionally, authored navigation meshes can only be used in a static rebasing context. Particle Systems World-space particle simulations may or may not behave as expected depending on the rebasing strategy that is used by the high precision rendering scheme. If dynamic rebasing updates the HPRoot , particles simulated in world space will appear to jump around as a function of the rebasing. Scripts Any script that reads world-space positions will likely behave strangely when using the High Precision Framework. These scripts would need to be written such that only relative values are used or so that they use the HPTransform component rather than the Transform component. Shaders Shaders that rely on world space coordinates, such as tri-planar shaders will behave oddly when used with the High Precision Framework as the world space is constantly being adjusted with dynamic rebasing schemes. Baked Lighting Baked lighting is not supported due to the unavailability of the streamed data at editor time. However, textures with lighting data can be published to the source and streamed using unlit materials. Occlusion Culling As occlusion culling requires static editor-time geometry, it is not supported. Individual layers decoders may support their own implementation of occlusion culling to improve performance and improve bandwidth requirements."
  },
  "manual/guide.html": {
    "href": "manual/guide.html",
    "title": "Package documentation guides | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "Package documentation guides Use these guides to create preliminary, high-level documentation meant to introduce users to the feature and the sample files included in your package. There are several types of packages: Packages that include features that augment the Unity Editor or Runtime ( modules , tools , and libraries ). Packages that provide tests . Packages that include sample files. Packages that contain templates . Note: Use the specialized com.unity.template-starter-kit starter kit for templates. Simple packages usually only need a single MD file for documentation. For example, packages that contain only samples or tests that require a minimal explanation. For single-file documentation, use the package name as the filename with the MD extension. For example, if your package is named com.unity.small-package , name your documentation file com.unity.small-package.md . If you are providing a package that contains a lot of tools, or requires a lot of explanation, you probably need to create more than one page of documentation. Multiple-page documentation provides a lot of information with a sidebar Table of Contents (TOC) where readers can easily see and understand the structure. How to use these guides This documentation set itself is an example of how to set up more complex documentation with multiple pages organized with a Table of Contents (TOC). However, you can also use these pages as guides for how to create single-page documentation: tools-package-guide.md for a package that includes features that augment the Unity Editor or Runtime (modules, tools, and libraries) sample-package-guide.md for a package that includes sample files test-package-guide.md for a package that provides tests Tip : You can also use the single-page guides to help create more complex documentation: start with one big MD file and then split it out later when you are happy with the structure. Alternatively, you can create the overall structure in the TableOfContents.md file and then create the individual MD files as you go along. For more information on using multi-page documentation, see the Confluence page User Manual formatting (packages) . The guide pages contain some example text to get you started, along with some instructions displayed as Notes . In addition, there are a few real-world examples displayed in italics which are there for reference only. Delete all of the instructions and examples, and then remove any other sections or text you don't need. When you want to review the overall structure or test how the documentation will look online, use the Package Manager's DocTools extension. For more information, see the instructions on Confluence for installing the DocTools package . Then open your package in the Package Manager and click the Generate Documentation button. DocFx generates a version using your localserver. Markdown for single vs. multiple MD files If you are creating a single MD file for your documentation, you can use a Heading 1 section to add more topics. Use the # character followed by your title: # Heading 1 section Here are the contents of your main topic. If you need to split a main topic into smaller subtopics, use a Heading 2 section: ## Heading 2 section Here are the contents of your subtopic. If you are creating documentation with a Table of Contents and multiple MD files, you can put each main topic in its own page. Other than that, you can use virtually the same markdown. The only real difference is when creating links. Links to other topics If you want to link to a specific topic, add an anchor (bookmark) just before the heading: <a name=\"anchorID\"></a> # Heading 1 section Here are the contents of your main topic. Note : Anchor links must be unique inside an MD file. If the topic you are linking to is defined in the same file as the link, add a markdown link to the anchorID you used: ... And here is the text where the [link](#anchorID) appears. ... <a name=\"anchorID\"></a> # Heading 1 section Here are the contents of your main topic. If the topic you are linking to is defined in a different file from the link, use the name of the page first: This is what an [external link](anotherfile.md#anchorID) looks like. If you are linking to a topic that comes first in another file, you can just use the name of the page on its own: This is what a [link to another page](anotherfile.md) looks like. Notice that in both cases, you have to specify the .md extension in the link text. Images If you have topics that include screen grabs or diagrams, add a link to the image after the paragraph with the instruction or description that references the image. In addition, a caption should be added to the image link that includes the name of the screen or diagram. All images must be PNG files with underscores for spaces. No animated GIFs. Here is an example of how to present a screen grab: Notice that the example screen shot is included in the images folder. All screen grabs and/or diagrams must be added and referenced from the images folder. For information and guidance on creating and adding screen grabs, see the Unity documentation standards . Structuring the information Most people need some orientation so they can understand what the purpose of the package is and what it contains, along with any important warnings or general information. This high-level information should appear in the First page or section . After providing this preliminary information, you can provide sections that contain: An overview of the user interface (if it's complicated) Directory listings (for samples) More in-depth workflows More advanced topics. Reference pages should appear near the end. Tip: For guidance on good writing practices, Unity documentation standards, and style guidelines, see the Unity Docs Style Guide . First page or section The initial section of the documentation should contain this information: Subsection Instructions/Description Title and introduction The title of the package (for example, About MyPackage ). After the title of the package, you should give a very brief overview of what the package does and what it contains. Experimental package , Pre-release package , or Installation The guides provide some boilerplate text inside of HTML comments (so they won't be generated by accident). Pick the appropriate section and move it out of the HTML comments. These sections include instructions for installing the package, which is a different procedure when your package is in early stages, so it's important to pick the appropriate section and change or remove that section when your package changes states. You should also provide any additional instructions to help the user complete the setup if necessary. Following the introduction, add the section that matches your package's state: - For packages that are In Development or Experimental, use the Experimental package section. - For packages that are Pre-release, use the Pre-release package section. - For packages that are Release Candidates or Released, use the Installation section. Package contents This section includes the location of important files you want the user to know about. For example, if this is a sample package containing textures, models, and materials separated by sample groups, you may want to provide the folder location of each group. Requirements [Optional] If your package requires anything other than the standard Unity system requirements, add this section. Known limitations [Optional] If your package has unresolved issues or limitations, enumerate them in this section. Helpful links [Optional] You can use this section to provide links for getting help and providing feedback, such as public forums or knowledge bases, helpdesk contacts, tutorials, and more. Subsequent pages or sections These are the suggested main topics you can add to your documentation after the first page or section: Section Instructions/Description Using <package-name> For packages that augment the Unity Editor with additional features, this section should include a high-level workflow. If there is more workflow, or it you need to provide more detail, consider adding a Workflows section. You can also include some information about your UI if your package implements a dialog, window, or component. If you have more than one set of properties or UI to document, consider adding a Reference section. For packages that include test or sample files, this section may include detailed information on how the user can use these in their Projects and Scenes. You can also include workflow diagrams or illustrations if it helps explain how to use your tests or samples. If this section begins to get really large, you can either divide it into smaller subsections or move some of the information to a new topic, including the Workflows , Advanced topics , or Reference sections. Workflows [Optional] This is where you can describe typical ways to use the tools, modules, libraries, etc. A workflow is a simple set of steps that the user can easily follow. Workflows demonstrate how to use the feature. Provide a list of steps containing screen grabs to better illustrate how to use the feature, and links to the more advanced topics or any reference pages . Advanced topics [Optional] This is where you can provide detailed information about what you are providing to users. This is ideal if you don't want to overwhelm the user with too much information up front. You can link to topics by dropping an anchor ( <a name=\"AnchorID\"></a> ) near the topic target and then creating an MD link with that anchor ID ( [display text for the link](#AnchorID) ) from another section. If you have a lot of advanced topics, you can create subsections and display a list of links to each one so your readers can easily find what they are looking for. Reference [Optional] If you have user interace with a lot of properties, you can provide the details in a reference section. Use tables, if possible, to describe properties. Reference tables should have two columns with the bolded name of the property on the left and the description of how to use it on the right.test-package-guide.md#reference) Remember : You don't have to stick to these exact sections. You can define your own topics, as long as you generally follow these principles: Provide some high-level information up front to orient your users. Provide the low-level information (such as properties reference) at the end. Provide the rest of the information in a series of topics in the middle. Depending on the complexity of your package, you might only have one topic after the introduction, or you might have several topics with sub-topics. Provide links to separate topics and sections that are related to give the user the fullest picture possible."
  },
  "manual/index.html": {
    "href": "manual/index.html",
    "title": "GIS Streaming Framework | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "GIS Streaming Framework Introduction The GIS Streaming Framework is designed to stream planet-scale environments into the Unity Editor. It is a flexible framework that provides an abstraction layer to the various geospatial layers that can be streamed into the engine. It also includes a streaming implementation for the OGC 3D Tiles format. Notice Currently, only 64 bit windows version is supported. The GIS Streaming Framework version v1.0.0-preview.2 is compatible with the following versions of the Unity Editor: 2020.3 and later The GIS Streaming Framework is not yet fully integrated with all of Unity's subsystems, such as physics and navigation mesh . See the dedicated page Known Limitations for more information. Package Dependencies The GIS Streaming Framework requires the following packages to be installed along-side it. Because theses packages are not in the Unity Registry, they must be installed manually: glTFast gis-high-precision-framework Getting Started First Time Setup Adding Multiple Datasets Frequently Asked Questions Known Limitations"
  },
  "manual/sample-package-guide.html": {
    "href": "manual/sample-package-guide.html",
    "title": "About <package name> samples | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "About <package name> samples The <package name> package includes samples of <name of Asset type, Model, Prefabs, and/or other GameObjects in the package>. For more information, see <xref to topic in the Unity Manual>. Note : Here is an example for reference only. Do not include it in the final documentation file. The Timeline Examples package includes examples of Timeline Assets, Timeline Instances, animation, GameObjects, and scripts that illustrate how to use Unity's Timeline. For more information, see Unity's Timeline in the Unity Manual. For licensing and usage, see Package Licensing. Note : For packages that are not yet released, see the Confluence page Documenting experimental, pre-release, and deprecated packages and refer to the appropriate section for your package's compatibility status for guidance on which installation instructions to include. Remember to remove or hide these instructions when the package is ready for release. When the package is at the Release Candidate or Released stage, use the Installation section below. Installation To install this package, follow the instructions in the Package Manager documentation . Note : This section begins with a cross-reference to the official Unity Manual topic on how to install packages. If the package requires special installation instructions, include these steps below: In addition, you need to install the following resources: <name of resource 1> : To install, open Window > <name of menu item> . The resource appears <at this location>. ... etc. --> Package contents The following table describes the package folder structure: Location Description MyFolderName Contains <describe what the folder contains>. MyFolderName/MyFileName Contains <describe what the file represents or implements>. Using <package name> To use the <sample-name>, make sure you have already imported the sample into your Project. Then you can ..."
  },
  "manual/TableOfContents.html": {
    "href": "manual/TableOfContents.html",
    "title": "| Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "GIS Streaming Framework Getting Started First Time Setup Adding Multiple Datasets Frequently Asked Questions Known Limitations Dataset Formats OGC 3D Tiles Unity Terrain Mesh Internal Architecture Universal Decoder"
  },
  "manual/test-package-guide.html": {
    "href": "manual/test-package-guide.html",
    "title": "About the <package name> tests | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "About the <package name> tests The <package name> package provides a test suite for the <feature or package name>. Note : For packages that are not yet released, see the Confluence page Documenting experimental, pre-release, and deprecated packages and refer to the appropriate section for your package's compatibility status for guidance on which installation instructions to include. Remember to remove or hide these instructions when the package is ready for release. When the package is at the Release Candidate or Released stage, use the Installation section below. Installation To install this package, follow the instructions in the Package Manager documentation . Note : This section begins with a cross-reference to the official Unity Manual topic on how to install packages. If the package requires special installation instructions, include these steps below: In addition, you need to install the following resources: <name of resource 1> : To install, open Window > <name of menu item> . The resource appears <at this location>. ... etc. --> Package contents The following table describes the package folder structure: Location Description MyFolderName Contains <describe what the folder contains>. MyFolderName/MyFileName Contains <describe what the file represents or implements>. Running the tests To use the <test-name>, make sure you have ..."
  },
  "manual/tools-package-guide.html": {
    "href": "manual/tools-package-guide.html",
    "title": "About <package name> | Unity Geospatial Streaming | 1.0.0-preview.2",
    "keywords": "About <package name> Use the <package name> package to <list of the main uses for the package>. For example, you can use <package name> to create/generate/extend/capture <mention major use case, or a good example of what the package can be used for>. The <package name> package also includes <other relevant features or uses>. Note : Here are some examples for reference only. Do not include these in the final documentation file. Use the Unity Recorder package to capture and save in-game data. For example, use Unity Recorder to record an mp4 file during a game session. The Unity Recorder package also includes an interface for setting-up and triggering recording sessions. AR Foundation allows you to work with augmented reality platforms in a multi-platform way within Unity. AR Foundation is a set of MonoBehaviour s and APIs for dealing with devices that support the following concepts: World tracking: track the device's position and orientation in physical space. Plane detection: detect horizontal and vertical surfaces. Point clouds, also known as feature points. ... etc. Note : For packages that are not yet released, see the Confluence page Documenting experimental, pre-release, and deprecated packages and refer to the appropriate section for your package's compatibility status for guidance on which installation instructions to include. Remember to remove or hide these instructions when the package is ready for release. When the package is at the Release Candidate or Released stage, use the Installation section below. Installation To install this package, follow the instructions in the Package Manager documentation . Note : This section begins with a cross-reference to the official Unity Manual topic on how to install packages. If the package requires special installation instructions, include these steps below: In addition, you need to install the following resources: <name of resource 1> : To install, open Window > <name of menu item> . The resource appears <at this location>. ... etc. --> Package contents The following table describes the package folder structure: Location Description MyFolderName Contains <describe what the folder contains>. MyFolderName/MyFileName Contains <describe what the file represents or implements>. Requirements This version of <package name> is compatible with the following versions of the Unity Editor: 2018.1 and later (recommended) Note : You may also include additional requirements or recommendations for 3rd party software or hardware. If you need to include references to non-Unity products, make sure you refer to these products correctly and that all references include the proper copyright (©), trademark (™) or registered trademark(®): To use this package, you must have the following 3rd party products: <product name and version>™ ...etc. Known limitations <package name> version <package version> includes the following known limitations: <brief one-line description of limitation.> ... etc. Note : If there are no known limitations, or if the limitations are trivial, exclude this section. Here is an example for reference only. Do not include this in the final documentation file: The Unity Recorder version 1.0 has the following limitations: The Unity Recorder does not support sound. The Recorder window and Recorder properties are not available in standalone Players. MP4 encoding is only available on Windows. Helpful links If you are new to <package-name>, or have a question after reading the documentation, you can: Watch the Tutorials here. Join our support forum . Follow us on Twitter . Using <package name> To use the <tool-name>, attach this component to your GameObject and open the <component-name> in the Inspector: ![The XXX component](images/LOCATION-OF-SCREENGRAB) Use this component to access the YYY and ZZZ properties which control ... Note : For a package containing a library, you can use this type of a description: The XXX and YYY libraries contain APIs which allow you to <do-something>. The <class-name> class extends the <other-class-name> class so you can ... You can implement a <something> using the XXX: using Unity.Editor; using MyPackage; namespace MyNamespace { public class MyClass { ... } } <package name> workflows To edit objects and elements: Decide which tools can help you achieve the end results. There might be multiple solutions that can all produce the effect you want. Select the element(s) that you want to modify. Often, the editing tool impacts which elements you need to select and how you need to select them. Depending on which tool you are using, set any options to help customize the outcome or change the default settings. Perform the action. Depending on what you are doing, this may be a simple matter of clicking a button. In some cases, you may be carrying out some intricate procedures. For example, you can click to ... Advanced topics This section provides more information on the following topics: First topic : provides a list of ... Second topic : explains the origin of ... etc. First topic This is a list of ... Second topic The XXX extends the YYY by tracking the ... XXX window You can access these properties on the XXX window: Property: Function: MySlider Set this value to ... MyCheckbox Enable this property to ... MyDropdownMenu Choose how you want to ... Value 1 Select this value if ... This is the default. Value 2 Select this value if ... Value 3 Select this value if ... MyReference Set a reference to ..."
  }
}